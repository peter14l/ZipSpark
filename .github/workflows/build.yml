name: Build ZipSpark

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest
    
    strategy:
      matrix:
        configuration: [Debug, Release]
        platform: [x64]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2

    - name: Setup NuGet
      uses: NuGet/setup-nuget@v2

    - name: Cache vcpkg
      uses: actions/cache@v4
      with:
        path: |
          vcpkg
          !vcpkg/.git
          !vcpkg/buildtrees
          !vcpkg/downloads
        key: ${{ runner.os }}-vcpkg-${{ hashFiles('packages.config') }}
        restore-keys: |
          ${{ runner.os }}-vcpkg-

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('packages.config') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Setup vcpkg
      run: |
        if (-not (Test-Path "vcpkg\vcpkg.exe")) {
          Write-Host "vcpkg not cached, cloning and bootstrapping..."
          git clone https://github.com/Microsoft/vcpkg.git
          cd vcpkg
          .\bootstrap-vcpkg.bat
          cd ..
        } else {
          Write-Host "vcpkg found in cache, skipping clone and bootstrap"
        }
        cd vcpkg
        .\vcpkg integrate install
        cd ..

    - name: Set vcpkg root
      run: echo "VCPKG_ROOT=$PWD\vcpkg" >> $env:GITHUB_ENV

    - name: Install libarchive
      run: |
        if (-not (Test-Path "vcpkg\installed\x64-windows-static\include\archive.h")) {
          Write-Host "Installing libarchive..."
          .\vcpkg\vcpkg install libarchive:x64-windows-static
        } else {
          Write-Host "libarchive found in cache, skipping installation"
        }
        echo "Libarchive installed/verified successfully"
        
    - name: Set vcpkg environment
      run: |
        echo "VCPKG_DEFAULT_TRIPLET=x64-windows-static" >> $env:GITHUB_ENV
        echo "CMAKE_TOOLCHAIN_FILE=$env:VCPKG_ROOT\scripts\buildsystems\vcpkg.cmake" >> $env:GITHUB_ENV

    - name: Restore NuGet packages
      run: nuget restore packages.config -PackagesDirectory packages

    - name: Increment MSIX version
      run: |
        $manifestPath = "Package.appxmanifest"
        [xml]$manifest = Get-Content $manifestPath
        
        # Get current version
        $currentVersion = $manifest.Package.Identity.Version
        Write-Host "Current version: $currentVersion"
        
        # Parse version (format: Major.Minor.Build.Revision)
        $versionParts = $currentVersion.Split('.')
        $major = [int]$versionParts[0]
        $minor = [int]$versionParts[1]
        $build = [int]$versionParts[2]
        $revision = [int]$versionParts[3]
        
        # Increment build number (or use GitHub run number)
        $newBuild = ${{ github.run_number }}
        $newVersion = "$major.$minor.$newBuild.0"
        
        Write-Host "New version: $newVersion"
        
        # Update manifest
        $manifest.Package.Identity.Version = $newVersion
        $manifest.Save($manifestPath)
        
        Write-Host "Version updated successfully!"
        
        # Set output for later use
        echo "VERSION=$newVersion" >> $env:GITHUB_ENV


    - name: Decode certificate
      if: matrix.configuration == 'Release' && github.event_name != 'pull_request'
      run: |
        if ("${{ secrets.CERTIFICATE_BASE64 }}" -ne "") {
          $base64 = "${{ secrets.CERTIFICATE_BASE64 }}"
          $bytes = [System.Convert]::FromBase64String($base64)
          $certPath = Join-Path $env:GITHUB_WORKSPACE "ZipSpark_TemporaryKey.pfx"
          [System.IO.File]::WriteAllBytes($certPath, $bytes)
          Write-Host "Certificate decoded to: $certPath"
          Write-Host "Certificate file exists: $(Test-Path $certPath)"
        } else {
          Write-Host "WARNING: No certificate found in secrets - MSIX will be unsigned"
        }

    - name: Build project
      run: |
        $vcpkgRoot = "$PWD\vcpkg"
        $vcpkgInclude = "$vcpkgRoot\installed\x64-windows-static\include"
        $vcpkgLib = "$vcpkgRoot\installed\x64-windows-static\lib"
        
        # Debug: Show paths
        Write-Host "vcpkg Include: $vcpkgInclude"
        Write-Host "vcpkg Lib: $vcpkgLib"
        Write-Host "Files in include dir:"
        Get-ChildItem $vcpkgInclude -ErrorAction SilentlyContinue | Select-Object -First 10
        
        # Set VCPKG_ROOT for vcxproj to use
        $env:VCPKG_ROOT = $vcpkgRoot
        
        if ("${{ matrix.configuration }}" -eq "Release" -and (Test-Path "ZipSpark_TemporaryKey.pfx")) {
          Write-Host "Building with certificate signing..."
          msbuild ZipSpark-New.vcxproj /p:Configuration=${{ matrix.configuration }} /p:Platform=${{ matrix.platform }} /p:AppxBundle=Never /p:UapAppxPackageBuildMode=SideloadOnly /p:AppxPackageDir=AppPackages\ /p:GenerateAppxPackageOnBuild=true /p:AppxPackageSigningEnabled=true /p:PackageCertificateKeyFile=ZipSpark_TemporaryKey.pfx /p:PackageCertificatePassword="${{ secrets.CERTIFICATE_PASSWORD }}" /m /v:minimal
        } else {
          Write-Host "Building without certificate signing..."
          msbuild ZipSpark-New.vcxproj /p:Configuration=${{ matrix.configuration }} /p:Platform=${{ matrix.platform }} /p:AppxBundle=Never /p:UapAppxPackageBuildMode=SideloadOnly /p:AppxPackageDir=AppPackages\ /p:GenerateAppxPackageOnBuild=true /m /v:minimal
        }

    - name: Upload MSIX package
      if: matrix.configuration == 'Release'
      uses: actions/upload-artifact@v4
      with:
        name: ZipSpark-MSIX-${{ matrix.platform }}-v${{ env.VERSION }}
        path: AppPackages/**/*.msix

    - name: Upload build artifacts
      if: matrix.configuration == 'Release'
      uses: actions/upload-artifact@v4
      with:
        name: ZipSpark-${{ matrix.platform }}-${{ matrix.configuration }}
        path: |
          ${{ matrix.platform }}/${{ matrix.configuration }}/ZipSpark-New/**/*
          !${{ matrix.platform }}/${{ matrix.configuration }}/**/*.pdb
          !${{ matrix.platform }}/${{ matrix.configuration }}/**/*.ipdb
          !${{ matrix.platform }}/${{ matrix.configuration }}/**/*.iobj
